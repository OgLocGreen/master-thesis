// Generated by gencpp from file irobot_fcpp_simul/IROBOT_ir_dataRequest.msg
// DO NOT EDIT!


#ifndef IROBOT_FCPP_SIMUL_MESSAGE_IROBOT_IR_DATAREQUEST_H
#define IROBOT_FCPP_SIMUL_MESSAGE_IROBOT_IR_DATAREQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <geometry_msgs/Polygon.h>

namespace irobot_fcpp_simul
{
template <class ContainerAllocator>
struct IROBOT_ir_dataRequest_
{
  typedef IROBOT_ir_dataRequest_<ContainerAllocator> Type;

  IROBOT_ir_dataRequest_()
    : load_inputdata(false)
    , load_polygon(false)
    , get_input_data(false)
    , get_working_zonesh(false)
    , get_working_zonesc(false)
    , get_inspection_zones(false)
    , get_rot_zone(false)
    , compute_adquireimgs(false)
    , compute_panorama(false)
    , merge_panoramas(false)
    , compute_detectpolys(false)
    , compute_fcpp_defect_i(false)
    , compute_fcpp_zone_i(false)
    , compute_fcpp_inspection_zone_i(false)
    , execute_fcpp_defect_i(false)
    , execute_fcpp_zone_i(false)
    , change_defect_reparation_goal(false)
    , change_inspection_goal(false)
    , get_poly_i(false)
    , get_defect_i(false)
    , get_defect_path(false)
    , get_inspection_i(false)
    , get_inspection_path(false)
    , activate_vizs(false)
    , long_robotx(0.0)
    , long_roboty(0.0)
    , long_herrx(0.0)
    , long_herry(0.0)
    , tras_herrx(0.0)
    , tras_herry(0.0)
    , long_camx(0.0)
    , long_camy(0.0)
    , tras_camx(0.0)
    , tras_camy(0.0)
    , long_areax(0.0)
    , long_areay(0.0)
    , input_poly()
    , id_poly(0)
    , id_defecto(0)
    , id_zona(0)  {
    }
  IROBOT_ir_dataRequest_(const ContainerAllocator& _alloc)
    : load_inputdata(false)
    , load_polygon(false)
    , get_input_data(false)
    , get_working_zonesh(false)
    , get_working_zonesc(false)
    , get_inspection_zones(false)
    , get_rot_zone(false)
    , compute_adquireimgs(false)
    , compute_panorama(false)
    , merge_panoramas(false)
    , compute_detectpolys(false)
    , compute_fcpp_defect_i(false)
    , compute_fcpp_zone_i(false)
    , compute_fcpp_inspection_zone_i(false)
    , execute_fcpp_defect_i(false)
    , execute_fcpp_zone_i(false)
    , change_defect_reparation_goal(false)
    , change_inspection_goal(false)
    , get_poly_i(false)
    , get_defect_i(false)
    , get_defect_path(false)
    , get_inspection_i(false)
    , get_inspection_path(false)
    , activate_vizs(false)
    , long_robotx(0.0)
    , long_roboty(0.0)
    , long_herrx(0.0)
    , long_herry(0.0)
    , tras_herrx(0.0)
    , tras_herry(0.0)
    , long_camx(0.0)
    , long_camy(0.0)
    , tras_camx(0.0)
    , tras_camy(0.0)
    , long_areax(0.0)
    , long_areay(0.0)
    , input_poly(_alloc)
    , id_poly(0)
    , id_defecto(0)
    , id_zona(0)  {
  (void)_alloc;
    }



   typedef uint8_t _load_inputdata_type;
  _load_inputdata_type load_inputdata;

   typedef uint8_t _load_polygon_type;
  _load_polygon_type load_polygon;

   typedef uint8_t _get_input_data_type;
  _get_input_data_type get_input_data;

   typedef uint8_t _get_working_zonesh_type;
  _get_working_zonesh_type get_working_zonesh;

   typedef uint8_t _get_working_zonesc_type;
  _get_working_zonesc_type get_working_zonesc;

   typedef uint8_t _get_inspection_zones_type;
  _get_inspection_zones_type get_inspection_zones;

   typedef uint8_t _get_rot_zone_type;
  _get_rot_zone_type get_rot_zone;

   typedef uint8_t _compute_adquireimgs_type;
  _compute_adquireimgs_type compute_adquireimgs;

   typedef uint8_t _compute_panorama_type;
  _compute_panorama_type compute_panorama;

   typedef uint8_t _merge_panoramas_type;
  _merge_panoramas_type merge_panoramas;

   typedef uint8_t _compute_detectpolys_type;
  _compute_detectpolys_type compute_detectpolys;

   typedef uint8_t _compute_fcpp_defect_i_type;
  _compute_fcpp_defect_i_type compute_fcpp_defect_i;

   typedef uint8_t _compute_fcpp_zone_i_type;
  _compute_fcpp_zone_i_type compute_fcpp_zone_i;

   typedef uint8_t _compute_fcpp_inspection_zone_i_type;
  _compute_fcpp_inspection_zone_i_type compute_fcpp_inspection_zone_i;

   typedef uint8_t _execute_fcpp_defect_i_type;
  _execute_fcpp_defect_i_type execute_fcpp_defect_i;

   typedef uint8_t _execute_fcpp_zone_i_type;
  _execute_fcpp_zone_i_type execute_fcpp_zone_i;

   typedef uint8_t _change_defect_reparation_goal_type;
  _change_defect_reparation_goal_type change_defect_reparation_goal;

   typedef uint8_t _change_inspection_goal_type;
  _change_inspection_goal_type change_inspection_goal;

   typedef uint8_t _get_poly_i_type;
  _get_poly_i_type get_poly_i;

   typedef uint8_t _get_defect_i_type;
  _get_defect_i_type get_defect_i;

   typedef uint8_t _get_defect_path_type;
  _get_defect_path_type get_defect_path;

   typedef uint8_t _get_inspection_i_type;
  _get_inspection_i_type get_inspection_i;

   typedef uint8_t _get_inspection_path_type;
  _get_inspection_path_type get_inspection_path;

   typedef uint8_t _activate_vizs_type;
  _activate_vizs_type activate_vizs;

   typedef float _long_robotx_type;
  _long_robotx_type long_robotx;

   typedef float _long_roboty_type;
  _long_roboty_type long_roboty;

   typedef float _long_herrx_type;
  _long_herrx_type long_herrx;

   typedef float _long_herry_type;
  _long_herry_type long_herry;

   typedef float _tras_herrx_type;
  _tras_herrx_type tras_herrx;

   typedef float _tras_herry_type;
  _tras_herry_type tras_herry;

   typedef float _long_camx_type;
  _long_camx_type long_camx;

   typedef float _long_camy_type;
  _long_camy_type long_camy;

   typedef float _tras_camx_type;
  _tras_camx_type tras_camx;

   typedef float _tras_camy_type;
  _tras_camy_type tras_camy;

   typedef float _long_areax_type;
  _long_areax_type long_areax;

   typedef float _long_areay_type;
  _long_areay_type long_areay;

   typedef  ::geometry_msgs::Polygon_<ContainerAllocator>  _input_poly_type;
  _input_poly_type input_poly;

   typedef int32_t _id_poly_type;
  _id_poly_type id_poly;

   typedef int32_t _id_defecto_type;
  _id_defecto_type id_defecto;

   typedef int32_t _id_zona_type;
  _id_zona_type id_zona;





  typedef boost::shared_ptr< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> const> ConstPtr;

}; // struct IROBOT_ir_dataRequest_

typedef ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<std::allocator<void> > IROBOT_ir_dataRequest;

typedef boost::shared_ptr< ::irobot_fcpp_simul::IROBOT_ir_dataRequest > IROBOT_ir_dataRequestPtr;
typedef boost::shared_ptr< ::irobot_fcpp_simul::IROBOT_ir_dataRequest const> IROBOT_ir_dataRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace irobot_fcpp_simul

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'actionlib_msgs': ['/opt/ros/kinetic/share/actionlib_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg', '/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'irobot_fcpp_simul': ['/home/irobot/catkin_ws/src/irobot_fcpp_simul/msg', '/home/irobot/catkin_ws/devel/share/irobot_fcpp_simul/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "4ddaa5ae62cec8855391a0625162d979";
  }

  static const char* value(const ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x4ddaa5ae62cec885ULL;
  static const uint64_t static_value2 = 0x5391a0625162d979ULL;
};

template<class ContainerAllocator>
struct DataType< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "irobot_fcpp_simul/IROBOT_ir_dataRequest";
  }

  static const char* value(const ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool load_inputdata\n\
bool load_polygon\n\
\n\
bool get_input_data\n\
bool get_working_zonesh\n\
bool get_working_zonesc\n\
bool get_inspection_zones\n\
bool get_rot_zone\n\
\n\
\n\
bool compute_adquireimgs\n\
bool compute_panorama\n\
bool merge_panoramas\n\
bool compute_detectpolys\n\
\n\
bool compute_fcpp_defect_i\n\
bool compute_fcpp_zone_i\n\
bool compute_fcpp_inspection_zone_i\n\
\n\
bool execute_fcpp_defect_i\n\
bool execute_fcpp_zone_i\n\
\n\
bool change_defect_reparation_goal\n\
bool change_inspection_goal\n\
\n\
\n\
bool get_poly_i\n\
bool get_defect_i\n\
bool get_defect_path\n\
\n\
bool get_inspection_i\n\
bool get_inspection_path\n\
\n\
bool activate_vizs\n\
\n\
\n\
float32 long_robotx\n\
float32 long_roboty\n\
\n\
\n\
float32 long_herrx\n\
float32 long_herry\n\
float32 tras_herrx\n\
float32 tras_herry\n\
\n\
\n\
float32 long_camx\n\
float32 long_camy\n\
float32 tras_camx\n\
float32 tras_camy\n\
\n\
\n\
float32 long_areax\n\
float32 long_areay\n\
\n\
\n\
geometry_msgs/Polygon input_poly\n\
\n\
\n\
int32 id_poly\n\
\n\
\n\
int32 id_defecto\n\
\n\
\n\
int32 id_zona\n\
\n\
\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Polygon\n\
#A specification of a polygon where the first and last points are assumed to be connected\n\
Point32[] points\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Point32\n\
# This contains the position of a point in free space(with 32 bits of precision).\n\
# It is recommeded to use Point wherever possible instead of Point32.  \n\
# \n\
# This recommendation is to promote interoperability.  \n\
#\n\
# This message is designed to take up less space when sending\n\
# lots of points at once, as in the case of a PointCloud.  \n\
\n\
float32 x\n\
float32 y\n\
float32 z\n\
";
  }

  static const char* value(const ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.load_inputdata);
      stream.next(m.load_polygon);
      stream.next(m.get_input_data);
      stream.next(m.get_working_zonesh);
      stream.next(m.get_working_zonesc);
      stream.next(m.get_inspection_zones);
      stream.next(m.get_rot_zone);
      stream.next(m.compute_adquireimgs);
      stream.next(m.compute_panorama);
      stream.next(m.merge_panoramas);
      stream.next(m.compute_detectpolys);
      stream.next(m.compute_fcpp_defect_i);
      stream.next(m.compute_fcpp_zone_i);
      stream.next(m.compute_fcpp_inspection_zone_i);
      stream.next(m.execute_fcpp_defect_i);
      stream.next(m.execute_fcpp_zone_i);
      stream.next(m.change_defect_reparation_goal);
      stream.next(m.change_inspection_goal);
      stream.next(m.get_poly_i);
      stream.next(m.get_defect_i);
      stream.next(m.get_defect_path);
      stream.next(m.get_inspection_i);
      stream.next(m.get_inspection_path);
      stream.next(m.activate_vizs);
      stream.next(m.long_robotx);
      stream.next(m.long_roboty);
      stream.next(m.long_herrx);
      stream.next(m.long_herry);
      stream.next(m.tras_herrx);
      stream.next(m.tras_herry);
      stream.next(m.long_camx);
      stream.next(m.long_camy);
      stream.next(m.tras_camx);
      stream.next(m.tras_camy);
      stream.next(m.long_areax);
      stream.next(m.long_areay);
      stream.next(m.input_poly);
      stream.next(m.id_poly);
      stream.next(m.id_defecto);
      stream.next(m.id_zona);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct IROBOT_ir_dataRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::irobot_fcpp_simul::IROBOT_ir_dataRequest_<ContainerAllocator>& v)
  {
    s << indent << "load_inputdata: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.load_inputdata);
    s << indent << "load_polygon: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.load_polygon);
    s << indent << "get_input_data: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_input_data);
    s << indent << "get_working_zonesh: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_working_zonesh);
    s << indent << "get_working_zonesc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_working_zonesc);
    s << indent << "get_inspection_zones: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_inspection_zones);
    s << indent << "get_rot_zone: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_rot_zone);
    s << indent << "compute_adquireimgs: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compute_adquireimgs);
    s << indent << "compute_panorama: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compute_panorama);
    s << indent << "merge_panoramas: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.merge_panoramas);
    s << indent << "compute_detectpolys: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compute_detectpolys);
    s << indent << "compute_fcpp_defect_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compute_fcpp_defect_i);
    s << indent << "compute_fcpp_zone_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compute_fcpp_zone_i);
    s << indent << "compute_fcpp_inspection_zone_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.compute_fcpp_inspection_zone_i);
    s << indent << "execute_fcpp_defect_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.execute_fcpp_defect_i);
    s << indent << "execute_fcpp_zone_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.execute_fcpp_zone_i);
    s << indent << "change_defect_reparation_goal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.change_defect_reparation_goal);
    s << indent << "change_inspection_goal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.change_inspection_goal);
    s << indent << "get_poly_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_poly_i);
    s << indent << "get_defect_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_defect_i);
    s << indent << "get_defect_path: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_defect_path);
    s << indent << "get_inspection_i: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_inspection_i);
    s << indent << "get_inspection_path: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.get_inspection_path);
    s << indent << "activate_vizs: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.activate_vizs);
    s << indent << "long_robotx: ";
    Printer<float>::stream(s, indent + "  ", v.long_robotx);
    s << indent << "long_roboty: ";
    Printer<float>::stream(s, indent + "  ", v.long_roboty);
    s << indent << "long_herrx: ";
    Printer<float>::stream(s, indent + "  ", v.long_herrx);
    s << indent << "long_herry: ";
    Printer<float>::stream(s, indent + "  ", v.long_herry);
    s << indent << "tras_herrx: ";
    Printer<float>::stream(s, indent + "  ", v.tras_herrx);
    s << indent << "tras_herry: ";
    Printer<float>::stream(s, indent + "  ", v.tras_herry);
    s << indent << "long_camx: ";
    Printer<float>::stream(s, indent + "  ", v.long_camx);
    s << indent << "long_camy: ";
    Printer<float>::stream(s, indent + "  ", v.long_camy);
    s << indent << "tras_camx: ";
    Printer<float>::stream(s, indent + "  ", v.tras_camx);
    s << indent << "tras_camy: ";
    Printer<float>::stream(s, indent + "  ", v.tras_camy);
    s << indent << "long_areax: ";
    Printer<float>::stream(s, indent + "  ", v.long_areax);
    s << indent << "long_areay: ";
    Printer<float>::stream(s, indent + "  ", v.long_areay);
    s << indent << "input_poly: ";
    s << std::endl;
    Printer< ::geometry_msgs::Polygon_<ContainerAllocator> >::stream(s, indent + "  ", v.input_poly);
    s << indent << "id_poly: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id_poly);
    s << indent << "id_defecto: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id_defecto);
    s << indent << "id_zona: ";
    Printer<int32_t>::stream(s, indent + "  ", v.id_zona);
  }
};

} // namespace message_operations
} // namespace ros

#endif // IROBOT_FCPP_SIMUL_MESSAGE_IROBOT_IR_DATAREQUEST_H
